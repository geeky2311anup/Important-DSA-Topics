# ðŸ§  Intuition
When we look at numbers whose binary representations are made entirely of **1's**,  
we notice a clear mathematical pattern:

| Binary | Decimal |
|:-------:|:---------:|
| `1` | 1 |
| `11` | 3 |
| `111` | 7 |
| `1111` | 15 |
| `11111` | 31 |

All these numbers can be expressed as:

\[
2^k - 1
\]

So, the task is simple:  
ðŸ‘‰ Find the **smallest** `x = 2^k - 1` such that `x â‰¥ n`.

---

# ðŸš€ Approach

1. **Find the position of the most significant bit (MSB)** in `n`.  
   - This gives the highest power of 2 that fits inside `n`.  
   - We can find this using `log2(n)`.

2. **Generate the next all-set-bits number.**  
   - For example, if `n = 10 (1010â‚‚)`, the MSB is at position 3.  
   - The next all-1s number is `(1 << (3 + 1)) - 1 = 15 (1111â‚‚)`.

3. **Return that number.**  
   - This ensures `x` is the smallest number â‰¥ `n` that has all bits set.

---

# âœ¨ Example Walkthrough

### Example 1
**Input:** `n = 5`  
**Binary:** `101â‚‚`  
- `log2(5) = 2` â†’ MSB at position 2  
- `(1 << (2 + 1)) - 1 = (1 << 3) - 1 = 7`  
âœ… **Output:** `7 (111â‚‚)`

---

### Example 2
**Input:** `n = 10`  
**Binary:** `1010â‚‚`  
- `log2(10) = 3` â†’ MSB at position 3  
- `(1 << (3 + 1)) - 1 = 15`  
âœ… **Output:** `15 (1111â‚‚)`

---

# ðŸ–¼ï¸ Visualization

Hereâ€™s a visual showing the pattern of **numbers with all bits set**:

![Binary Pattern Visualization](https://i.imgur.com/qW8Q6eK.png)
*(Replace this URL with your own uploaded image from Imgur or GitHub)*

---

# â±ï¸ Complexity

- **Time Complexity:** $$O(1)$$  
  We perform a single logarithmic and bitwise operation.

- **Space Complexity:** $$O(1)$$  
  No extra memory used apart from a few variables.

---

# ðŸ’» Code
```cpp
class Solution {
public:
    int smallestNumber(int n) {
        // Step 1: Find MSB position
        int d = (int)(log2(n));
        
        // Step 2: Generate number with all bits set up to MSB
        return (1 << (d + 1)) - 1;
    }
};
